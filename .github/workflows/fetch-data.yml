name: Fetch IZSU Data

on:
  # Manual trigger for testing
  workflow_dispatch:
  # Hourly schedule
  schedule:
    - cron: '0 * * * *'

jobs:
  fetch:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch IZSU Data
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
        run: |
          node << 'EOF'
          const https = require('https');

          // Skip SSL verification
          const agent = new https.Agent({ rejectUnauthorized: false });

          const ENDPOINTS = {
            barajdurum: 'https://openapi.izmir.bel.tr/api/izsu/barajdurum',
            barajvekuyular: 'https://openapi.izmir.bel.tr/api/izsu/barajvekuyular',
            gunluksuuretimi: 'https://openapi.izmir.bel.tr/api/izsu/gunluksuuretimi',
            suuretiminindagilimi: 'https://openapi.izmir.bel.tr/api/izsu/suuretiminindagilimi',
            arizakaynaklisukesintileri: 'https://openapi.izmir.bel.tr/api/izsu/arizakaynaklisukesintileri',
            haftaliksuanalizleri: 'https://openapi.izmir.bel.tr/api/izsu/haftaliksuanalizleri',
            cevreilcesuanalizleri: 'https://openapi.izmir.bel.tr/api/izsu/cevreilcesuanalizleri',
            barajsukaliteraporlari: 'https://openapi.izmir.bel.tr/api/izsu/barajsukaliteraporlari'
          };

          const RETRY_COUNT = 3;
          const TIMEOUT_MS = 30000;

          function fetchWithTimeout(url, timeoutMs) {
            return new Promise((resolve, reject) => {
              const chunks = [];
              let totalSize = 0;

              const req = https.get(url, { agent }, (res) => {
                res.on('data', chunk => {
                  chunks.push(chunk);
                  totalSize += chunk.length;
                });
                res.on('end', () => {
                  const buffer = Buffer.concat(chunks, totalSize);
                  resolve(buffer.toString('utf8'));
                });
                res.on('error', reject);
              });

              req.on('error', reject);
              req.setTimeout(timeoutMs, () => {
                req.destroy();
                reject(new Error('Request timeout'));
              });
            });
          }

          async function fetchEndpoint(name, url) {
            const startTime = Date.now();

            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const rawData = await fetchWithTimeout(url, TIMEOUT_MS);
                const elapsed = Date.now() - startTime;

                // Check if response is valid
                if (!rawData || rawData.trim() === '') {
                  throw new Error('Empty response');
                }

                // Try to parse JSON
                let parsed;
                try {
                  parsed = JSON.parse(rawData);
                } catch (parseErr) {
                  // Log first 200 chars for debugging
                  console.log(`  Parse error preview: ${rawData.substring(0, 200)}`);
                  throw new Error(`JSON parse error: ${parseErr.message}`);
                }

                // Check for API error in response
                if (parsed && parsed.message === 'An unexpected error occurred') {
                  throw new Error('API returned error message');
                }

                console.log(`✓ ${name}: ${elapsed}ms (${Math.round(rawData.length/1024)}KB)`);
                return { name, data: parsed, error: null };

              } catch (error) {
                const elapsed = Date.now() - startTime;
                console.log(`✗ ${name} attempt ${attempt}/${RETRY_COUNT}: ${error.message} (${elapsed}ms)`);

                if (attempt < RETRY_COUNT) {
                  // Wait before retry with exponential backoff
                  await new Promise(r => setTimeout(r, 1000 * attempt));
                }
              }
            }

            return { name, data: null, error: `Failed after ${RETRY_COUNT} attempts` };
          }

          async function updateGist(content) {
            const gistId = process.env.GIST_ID;
            const token = process.env.GIST_TOKEN;

            if (!gistId || !token) {
              console.log('No GIST_ID or GIST_TOKEN - skipping gist update');
              console.log('Data preview:', JSON.stringify(content, null, 2).slice(0, 1000));
              return;
            }

            const payload = JSON.stringify({
              files: {
                'izsu-data.json': {
                  content: JSON.stringify(content, null, 2)
                }
              }
            });

            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'api.github.com',
                path: `/gists/${gistId}`,
                method: 'PATCH',
                headers: {
                  'Authorization': `token ${token}`,
                  'User-Agent': 'IZSU-Fetcher',
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(payload)
                }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    console.log('✓ Gist updated successfully');
                    resolve();
                  } else {
                    console.log(`✗ Gist update failed: ${res.statusCode} - ${data.substring(0, 200)}`);
                    reject(new Error(`Gist update failed: ${res.statusCode}`));
                  }
                });
              });

              req.on('error', reject);
              req.write(payload);
              req.end();
            });
          }

          async function main() {
            const totalStart = Date.now();
            console.log('Starting IZSU data fetch...\n');

            // Fetch endpoints sequentially to avoid overwhelming the server
            const results = [];
            for (const [name, url] of Object.entries(ENDPOINTS)) {
              const result = await fetchEndpoint(name, url);
              results.push(result);
              // Small delay between requests
              await new Promise(r => setTimeout(r, 500));
            }

            // Build data object
            const data = {
              timestamp: new Date().toISOString(),
              endpoints: {}
            };

            let successCount = 0;
            let errorCount = 0;

            results.forEach(({ name, data: endpointData, error }) => {
              if (error) {
                data.endpoints[name] = { error };
                errorCount++;
              } else {
                data.endpoints[name] = endpointData;
                successCount++;
              }
            });

            console.log(`\nResults: ${successCount} success, ${errorCount} errors`);

            // Update gist
            await updateGist(data);

            const totalElapsed = Date.now() - totalStart;
            console.log(`\nTotal time: ${totalElapsed}ms (${(totalElapsed/1000).toFixed(1)}s)`);

            // Exit with error if too many failures
            if (errorCount > successCount) {
              console.log('\nToo many errors, exiting with failure');
              process.exit(1);
            }
          }

          main().catch(err => {
            console.error('Fatal error:', err);
            process.exit(1);
          });
          EOF

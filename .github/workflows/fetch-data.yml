name: Fetch IZSU Data

on:
  # Manual trigger for testing
  workflow_dispatch:
  # Hourly schedule
  schedule:
    - cron: '0 * * * *'

jobs:
  # Primary job: use GitHub-hosted runner
  fetch-primary:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      success: ${{ steps.fetch.outcome == 'success' }}
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch IZSU Data
        id: fetch
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
        run: |
          node << 'EOF'
          const http2 = require('http2');
          const https = require('https');

          // IZSU OpenAPI endpoints
          const currentYear = new Date().getFullYear();
          const ENDPOINTS = {
            barajdurum: '/api/izsu/barajdurum',
            barajvekuyular: '/api/izsu/barajvekuyular',
            gunluksuuretimi: '/api/izsu/gunluksuuretimi',
            arizakaynaklisukesintileri: '/api/izsu/arizakaynaklisukesintileri',
            haftaliksuanalizleri: '/api/izsu/haftaliksuanalizleri',
            cevreilcesuanalizleri: '/api/izsu/cevreilcesuanalizleri',
            barajsukaliteraporlari: '/api/izsu/barajsukaliteraporlari'
          };

          // Production distribution needs year parameter (2009-current)
          const PRODUCTION_START_YEAR = 2009;
          const IZSU_HOST = 'https://openapi.izmir.bel.tr';

          // CKAN endpoints (valid SSL)
          const CKAN_ENDPOINTS = {
            consumption: 'https://acikveri.bizizmir.com/api/3/action/datastore_search?resource_id=7a7485e5-2f04-4daf-9cc0-75ef1c24bc23&limit=0'
          };

          const RETRY_COUNT = 3;
          const TIMEOUT_MS = 30000;

          // Browser-like headers
          const BROWSER_HEADERS = {
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
            'accept-language': 'tr,en-US;q=0.9,en;q=0.8',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
          };

          // HTTP/2 client for IZSU (some endpoints require HTTP/2)
          let h2Client = null;

          function getH2Client() {
            if (!h2Client || h2Client.destroyed) {
              h2Client = http2.connect(IZSU_HOST, { rejectUnauthorized: false });
              h2Client.on('error', (err) => console.log('H2 client error:', err.message));
            }
            return h2Client;
          }

          function fetchWithHttp2(path, timeoutMs) {
            return new Promise((resolve, reject) => {
              const client = getH2Client();
              const chunks = [];
              let totalSize = 0;

              const req = client.request({
                ':path': path,
                ...BROWSER_HEADERS
              });

              const timeout = setTimeout(() => {
                req.close();
                reject(new Error('Request timeout'));
              }, timeoutMs);

              req.on('data', chunk => {
                chunks.push(chunk);
                totalSize += chunk.length;
              });

              req.on('end', () => {
                clearTimeout(timeout);
                const buffer = Buffer.concat(chunks, totalSize);
                resolve(buffer.toString('utf8'));
              });

              req.on('error', (err) => {
                clearTimeout(timeout);
                reject(err);
              });

              req.end();
            });
          }

          async function fetchEndpoint(name, path) {
            const startTime = Date.now();

            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const rawData = await fetchWithHttp2(path, TIMEOUT_MS);
                const elapsed = Date.now() - startTime;

                // Check if response is valid
                if (!rawData || rawData.trim() === '') {
                  throw new Error('Empty response');
                }

                // Try to parse JSON
                let parsed;
                try {
                  parsed = JSON.parse(rawData);
                } catch (parseErr) {
                  // Log first 200 chars for debugging
                  console.log(`  Parse error preview: ${rawData.substring(0, 200)}`);
                  throw new Error(`JSON parse error: ${parseErr.message}`);
                }

                // Check for API error in response
                if (parsed && parsed.message === 'An unexpected error occurred') {
                  throw new Error('API returned error message');
                }

                console.log(`✓ ${name}: ${elapsed}ms (${Math.round(rawData.length/1024)}KB)`);
                return { name, data: parsed, error: null };

              } catch (error) {
                const elapsed = Date.now() - startTime;
                console.log(`✗ ${name} attempt ${attempt}/${RETRY_COUNT}: ${error.message} (${elapsed}ms)`);

                if (attempt < RETRY_COUNT) {
                  // Wait before retry with exponential backoff
                  await new Promise(r => setTimeout(r, 1000 * attempt));
                }
              }
            }

            return { name, data: null, error: `Failed after ${RETRY_COUNT} attempts` };
          }

          // Fetch CKAN endpoint (valid SSL - no agent needed)
          async function fetchCkanEndpoint(name, url) {
            const startTime = Date.now();

            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const rawData = await new Promise((resolve, reject) => {
                  const chunks = [];
                  let totalSize = 0;

                  const req = https.get(url, { headers: BROWSER_HEADERS }, (res) => {
                    res.on('data', chunk => {
                      chunks.push(chunk);
                      totalSize += chunk.length;
                    });
                    res.on('end', () => {
                      const buffer = Buffer.concat(chunks, totalSize);
                      resolve(buffer.toString('utf8'));
                    });
                    res.on('error', reject);
                  });

                  req.on('error', reject);
                  req.setTimeout(TIMEOUT_MS, () => {
                    req.destroy();
                    reject(new Error('Request timeout'));
                  });
                });

                const elapsed = Date.now() - startTime;

                if (!rawData || rawData.trim() === '') {
                  throw new Error('Empty response');
                }

                let parsed;
                try {
                  parsed = JSON.parse(rawData);
                } catch (parseErr) {
                  console.log(`  Parse error preview: ${rawData.substring(0, 200)}`);
                  throw new Error(`JSON parse error: ${parseErr.message}`);
                }

                // CKAN returns { success: true, result: { total: N, ... } }
                if (parsed && parsed.success && parsed.result) {
                  console.log(`[CKAN] ${name}: ${elapsed}ms (total: ${parsed.result.total})`);
                  return { name, data: { total: parsed.result.total }, error: null };
                } else {
                  throw new Error('CKAN API returned unsuccessful response');
                }

              } catch (error) {
                const elapsed = Date.now() - startTime;
                console.log(`[CKAN] ${name} attempt ${attempt}/${RETRY_COUNT}: ${error.message} (${elapsed}ms)`);

                if (attempt < RETRY_COUNT) {
                  await new Promise(r => setTimeout(r, 1000 * attempt));
                }
              }
            }

            return { name, data: null, error: `Failed after ${RETRY_COUNT} attempts` };
          }

          async function updateGist(content) {
            const gistId = process.env.GIST_ID;
            const token = process.env.GIST_TOKEN;

            if (!gistId || !token) {
              console.log('No GIST_ID or GIST_TOKEN - skipping gist update');
              console.log('Data preview:', JSON.stringify(content, null, 2).slice(0, 1000));
              return;
            }

            const payload = JSON.stringify({
              files: {
                'izsu-data.json': {
                  content: JSON.stringify(content, null, 2)
                }
              }
            });

            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'api.github.com',
                path: `/gists/${gistId}`,
                method: 'PATCH',
                headers: {
                  'Authorization': `token ${token}`,
                  'User-Agent': 'IZSU-Fetcher',
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(payload)
                }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    console.log('✓ Gist updated successfully');
                    resolve();
                  } else {
                    console.log(`✗ Gist update failed: ${res.statusCode} - ${data.substring(0, 200)}`);
                    reject(new Error(`Gist update failed: ${res.statusCode}`));
                  }
                });
              });

              req.on('error', reject);
              req.write(payload);
              req.end();
            });
          }

          async function main() {
            const totalStart = Date.now();
            console.log('Starting IZSU data fetch...\n');

            // Fetch IZSU OpenAPI endpoints sequentially via HTTP/2
            const results = [];
            for (const [name, path] of Object.entries(ENDPOINTS)) {
              const result = await fetchEndpoint(name, path);
              results.push(result);
              await new Promise(r => setTimeout(r, 500));
            }

            // Fetch production distribution for all years (2009-current)
            console.log('\nFetching production distribution by year...');
            const productionData = [];
            for (let year = PRODUCTION_START_YEAR; year <= currentYear; year++) {
              const path = `/api/izsu/suuretiminindagilimi/${year}`;
              const result = await fetchEndpoint(`production_${year}`, path);
              if (!result.error && Array.isArray(result.data)) {
                productionData.push(...result.data);
              }
              await new Promise(r => setTimeout(r, 300));
            }

            // Fetch CKAN endpoints
            console.log('\nFetching CKAN data...');
            for (const [name, url] of Object.entries(CKAN_ENDPOINTS)) {
              const result = await fetchCkanEndpoint(name, url);
              results.push(result);
            }

            // Build data object
            const data = {
              timestamp: new Date().toISOString(),
              endpoints: {},
              ckan: {}
            };

            let successCount = 0;
            let errorCount = 0;

            results.forEach(({ name, data: endpointData, error }) => {
              // Check if it's a CKAN endpoint
              const isCkan = Object.keys(CKAN_ENDPOINTS).includes(name);
              const target = isCkan ? data.ckan : data.endpoints;

              if (error) {
                target[name] = { error };
                errorCount++;
              } else {
                target[name] = endpointData;
                successCount++;
              }
            });

            // Add merged production data
            data.endpoints.suuretiminindagilimi = productionData;
            if (productionData.length > 0) {
              successCount++;
              console.log(`suuretiminindagilimi: ${productionData.length} records (${PRODUCTION_START_YEAR}-${currentYear})`);
            }

            console.log(`\nResults: ${successCount} success, ${errorCount} errors`);

            // Update gist
            await updateGist(data);

            const totalElapsed = Date.now() - totalStart;
            console.log(`\nTotal time: ${totalElapsed}ms (${(totalElapsed/1000).toFixed(1)}s)`);

            // Close HTTP/2 client
            if (h2Client) {
              h2Client.close();
            }

            // Exit with error if too many failures
            if (errorCount > successCount) {
              console.log('\nToo many errors, exiting with failure');
              process.exit(1);
            }
          }

          main().catch(err => {
            console.error('Fatal error:', err);
            process.exit(1);
          });
          EOF

  # Fallback job: use self-hosted runner if primary fails
  fetch-fallback:
    runs-on: self-hosted
    needs: fetch-primary
    if: ${{ failure() }}
    timeout-minutes: 5
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch IZSU Data (Fallback)
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
        run: |
          echo "Primary job failed, running on self-hosted runner..."
          node << 'EOF'
          const http2 = require('http2');
          const https = require('https');

          const currentYear = new Date().getFullYear();
          const ENDPOINTS = {
            barajdurum: '/api/izsu/barajdurum',
            barajvekuyular: '/api/izsu/barajvekuyular',
            gunluksuuretimi: '/api/izsu/gunluksuuretimi',
            arizakaynaklisukesintileri: '/api/izsu/arizakaynaklisukesintileri',
            haftaliksuanalizleri: '/api/izsu/haftaliksuanalizleri',
            cevreilcesuanalizleri: '/api/izsu/cevreilcesuanalizleri',
            barajsukaliteraporlari: '/api/izsu/barajsukaliteraporlari'
          };

          const PRODUCTION_START_YEAR = 2009;
          const IZSU_HOST = 'https://openapi.izmir.bel.tr';
          const CKAN_ENDPOINTS = {
            consumption: 'https://acikveri.bizizmir.com/api/3/action/datastore_search?resource_id=7a7485e5-2f04-4daf-9cc0-75ef1c24bc23&limit=0'
          };

          const RETRY_COUNT = 3;
          const TIMEOUT_MS = 30000;
          const BROWSER_HEADERS = {
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'accept-language': 'tr,en-US;q=0.9,en;q=0.8',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/143.0.0.0 Safari/537.36'
          };

          let h2Client = null;
          function getH2Client() {
            if (!h2Client || h2Client.destroyed) {
              h2Client = http2.connect(IZSU_HOST, { rejectUnauthorized: false });
              h2Client.on('error', (err) => console.log('H2 error:', err.message));
            }
            return h2Client;
          }

          function fetchWithHttp2(path, timeoutMs) {
            return new Promise((resolve, reject) => {
              const client = getH2Client();
              const chunks = [];
              let totalSize = 0;
              const req = client.request({ ':path': path, ...BROWSER_HEADERS });
              const timeout = setTimeout(() => { req.close(); reject(new Error('Timeout')); }, timeoutMs);
              req.on('data', chunk => { chunks.push(chunk); totalSize += chunk.length; });
              req.on('end', () => { clearTimeout(timeout); resolve(Buffer.concat(chunks, totalSize).toString('utf8')); });
              req.on('error', (err) => { clearTimeout(timeout); reject(err); });
              req.end();
            });
          }

          async function fetchEndpoint(name, path) {
            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const raw = await fetchWithHttp2(path, TIMEOUT_MS);
                if (!raw || raw.trim() === '') throw new Error('Empty');
                const parsed = JSON.parse(raw);
                if (parsed?.message === 'An unexpected error occurred') throw new Error('API error');
                console.log('OK ' + name + ': ' + Math.round(raw.length/1024) + 'KB');
                return { name, data: parsed, error: null };
              } catch (e) {
                console.log('X ' + name + ' attempt ' + attempt + ': ' + e.message);
                if (attempt < RETRY_COUNT) await new Promise(r => setTimeout(r, 1000 * attempt));
              }
            }
            return { name, data: null, error: 'Failed' };
          }

          async function fetchCkanEndpoint(name, url) {
            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const raw = await new Promise((resolve, reject) => {
                  const chunks = [];
                  https.get(url, { headers: BROWSER_HEADERS }, (res) => {
                    res.on('data', c => chunks.push(c));
                    res.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
                    res.on('error', reject);
                  }).on('error', reject);
                });
                const parsed = JSON.parse(raw);
                if (parsed?.success && parsed?.result) {
                  console.log('[CKAN] ' + name + ': total=' + parsed.result.total);
                  return { name, data: { total: parsed.result.total }, error: null };
                }
                throw new Error('CKAN failed');
              } catch (e) {
                if (attempt < RETRY_COUNT) await new Promise(r => setTimeout(r, 1000 * attempt));
              }
            }
            return { name, data: null, error: 'Failed' };
          }

          async function updateGist(content) {
            const gistId = process.env.GIST_ID, token = process.env.GIST_TOKEN;
            if (!gistId || !token) { console.log('No gist credentials'); return; }
            const payload = JSON.stringify({ files: { 'izsu-data.json': { content: JSON.stringify(content, null, 2) } } });
            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'api.github.com', path: '/gists/' + gistId, method: 'PATCH',
                headers: { 'Authorization': 'token ' + token, 'User-Agent': 'IZSU', 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) }
              }, (res) => {
                let d = ''; res.on('data', c => d += c);
                res.on('end', () => { res.statusCode === 200 ? (console.log('Gist updated'), resolve()) : reject(new Error('Gist ' + res.statusCode)); });
              });
              req.on('error', reject); req.write(payload); req.end();
            });
          }

          async function main() {
            console.log('Starting fallback fetch...');
            const results = [];
            for (const [name, path] of Object.entries(ENDPOINTS)) {
              results.push(await fetchEndpoint(name, path));
              await new Promise(r => setTimeout(r, 500));
            }
            console.log('Fetching production data...');
            const productionData = [];
            for (let year = PRODUCTION_START_YEAR; year <= currentYear; year++) {
              const result = await fetchEndpoint('prod_' + year, '/api/izsu/suuretiminindagilimi/' + year);
              if (!result.error && Array.isArray(result.data)) productionData.push(...result.data);
              await new Promise(r => setTimeout(r, 300));
            }
            console.log('Fetching CKAN...');
            for (const [name, url] of Object.entries(CKAN_ENDPOINTS)) results.push(await fetchCkanEndpoint(name, url));

            const data = { timestamp: new Date().toISOString(), endpoints: {}, ckan: {} };
            let ok = 0, err = 0;
            results.forEach(({ name, data: d, error }) => {
              const t = Object.keys(CKAN_ENDPOINTS).includes(name) ? data.ckan : data.endpoints;
              if (error) { t[name] = { error }; err++; } else { t[name] = d; ok++; }
            });
            data.endpoints.suuretiminindagilimi = productionData;
            if (productionData.length > 0) ok++;
            console.log('Results: ' + ok + ' ok, ' + err + ' errors');
            await updateGist(data);
            if (h2Client) h2Client.close();
            if (err > ok) process.exit(1);
          }
          main().catch(e => { console.error('Fatal:', e); process.exit(1); });
          EOF

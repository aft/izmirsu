name: Fetch IZSU Data

on:
  # Manual trigger for testing
  workflow_dispatch:
  # Hourly schedule
  schedule:
    - cron: '0 * * * *'

jobs:
  # Primary job: use GitHub-hosted runner
  fetch-primary:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      success: ${{ steps.fetch.outcome == 'success' }}
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch IZSU Data
        id: fetch
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
        run: |
          node << 'EOF'
          const http2 = require('http2');
          const https = require('https');

          // IZSU OpenAPI endpoints
          const currentYear = new Date().getFullYear();
          const ENDPOINTS = {
            barajdurum: '/api/izsu/barajdurum',
            barajvekuyular: '/api/izsu/barajvekuyular',
            gunluksuuretimi: '/api/izsu/gunluksuuretimi',
            arizakaynaklisukesintileri: '/api/izsu/arizakaynaklisukesintileri',
            haftaliksuanalizleri: '/api/izsu/haftaliksuanalizleri',
            cevreilcesuanalizleri: '/api/izsu/cevreilcesuanalizleri',
            barajsukaliteraporlari: '/api/izsu/barajsukaliteraporlari'
          };

          // Production distribution needs year parameter (2009-current)
          const PRODUCTION_START_YEAR = 2009;
          const IZSU_HOST = 'https://openapi.izmir.bel.tr';

          // CKAN endpoints (valid SSL)
          const CKAN_ENDPOINTS = {
            consumption: 'https://acikveri.bizizmir.com/api/3/action/datastore_search?resource_id=7a7485e5-2f04-4daf-9cc0-75ef1c24bc23&limit=0'
          };

          const RETRY_COUNT = 3;
          const TIMEOUT_MS = 30000;

          // Browser-like headers
          const BROWSER_HEADERS = {
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
            'accept-language': 'tr,en-US;q=0.9,en;q=0.8',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
          };

          // HTTP/2 client for IZSU (some endpoints require HTTP/2)
          let h2Client = null;

          function getH2Client() {
            if (!h2Client || h2Client.destroyed) {
              h2Client = http2.connect(IZSU_HOST, { rejectUnauthorized: false });
              h2Client.on('error', (err) => console.log('H2 client error:', err.message));
            }
            return h2Client;
          }

          function fetchWithHttp2(path, timeoutMs) {
            return new Promise((resolve, reject) => {
              const client = getH2Client();
              const chunks = [];
              let totalSize = 0;

              const req = client.request({
                ':path': path,
                ...BROWSER_HEADERS
              });

              const timeout = setTimeout(() => {
                req.close();
                reject(new Error('Request timeout'));
              }, timeoutMs);

              req.on('data', chunk => {
                chunks.push(chunk);
                totalSize += chunk.length;
              });

              req.on('end', () => {
                clearTimeout(timeout);
                const buffer = Buffer.concat(chunks, totalSize);
                resolve(buffer.toString('utf8'));
              });

              req.on('error', (err) => {
                clearTimeout(timeout);
                reject(err);
              });

              req.end();
            });
          }

          async function fetchEndpoint(name, path) {
            const startTime = Date.now();

            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const rawData = await fetchWithHttp2(path, TIMEOUT_MS);
                const elapsed = Date.now() - startTime;

                // Check if response is valid
                if (!rawData || rawData.trim() === '') {
                  throw new Error('Empty response');
                }

                // Try to parse JSON
                let parsed;
                try {
                  parsed = JSON.parse(rawData);
                } catch (parseErr) {
                  // Log first 200 chars for debugging
                  console.log(`  Parse error preview: ${rawData.substring(0, 200)}`);
                  throw new Error(`JSON parse error: ${parseErr.message}`);
                }

                // Check for API error in response
                if (parsed && parsed.message === 'An unexpected error occurred') {
                  throw new Error('API returned error message');
                }

                console.log(`✓ ${name}: ${elapsed}ms (${Math.round(rawData.length/1024)}KB)`);
                return { name, data: parsed, error: null };

              } catch (error) {
                const elapsed = Date.now() - startTime;
                console.log(`✗ ${name} attempt ${attempt}/${RETRY_COUNT}: ${error.message} (${elapsed}ms)`);

                if (attempt < RETRY_COUNT) {
                  // Wait before retry with exponential backoff
                  await new Promise(r => setTimeout(r, 1000 * attempt));
                }
              }
            }

            return { name, data: null, error: `Failed after ${RETRY_COUNT} attempts` };
          }

          // Fetch CKAN endpoint (valid SSL - no agent needed)
          async function fetchCkanEndpoint(name, url) {
            const startTime = Date.now();

            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const rawData = await new Promise((resolve, reject) => {
                  const chunks = [];
                  let totalSize = 0;

                  const req = https.get(url, { headers: BROWSER_HEADERS }, (res) => {
                    res.on('data', chunk => {
                      chunks.push(chunk);
                      totalSize += chunk.length;
                    });
                    res.on('end', () => {
                      const buffer = Buffer.concat(chunks, totalSize);
                      resolve(buffer.toString('utf8'));
                    });
                    res.on('error', reject);
                  });

                  req.on('error', reject);
                  req.setTimeout(TIMEOUT_MS, () => {
                    req.destroy();
                    reject(new Error('Request timeout'));
                  });
                });

                const elapsed = Date.now() - startTime;

                if (!rawData || rawData.trim() === '') {
                  throw new Error('Empty response');
                }

                let parsed;
                try {
                  parsed = JSON.parse(rawData);
                } catch (parseErr) {
                  console.log(`  Parse error preview: ${rawData.substring(0, 200)}`);
                  throw new Error(`JSON parse error: ${parseErr.message}`);
                }

                // CKAN returns { success: true, result: { total: N, ... } }
                if (parsed && parsed.success && parsed.result) {
                  console.log(`[CKAN] ${name}: ${elapsed}ms (total: ${parsed.result.total})`);
                  return { name, data: { total: parsed.result.total }, error: null };
                } else {
                  throw new Error('CKAN API returned unsuccessful response');
                }

              } catch (error) {
                const elapsed = Date.now() - startTime;
                console.log(`[CKAN] ${name} attempt ${attempt}/${RETRY_COUNT}: ${error.message} (${elapsed}ms)`);

                if (attempt < RETRY_COUNT) {
                  await new Promise(r => setTimeout(r, 1000 * attempt));
                }
              }
            }

            return { name, data: null, error: `Failed after ${RETRY_COUNT} attempts` };
          }

          async function fetchGist() {
            const gistId = process.env.GIST_ID;
            const token = process.env.GIST_TOKEN;

            if (!gistId || !token) return null;

            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'api.github.com',
                path: `/gists/${gistId}`,
                method: 'GET',
                headers: {
                  'Authorization': `token ${token}`,
                  'User-Agent': 'IZSU-Fetcher',
                  'Accept': 'application/vnd.github.v3+json'
                }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    try {
                      const gist = JSON.parse(data);
                      const content = gist.files['izsu-data.json']?.content;
                      resolve(content ? JSON.parse(content) : null);
                    } catch (e) {
                      resolve(null);
                    }
                  } else {
                    resolve(null);
                  }
                });
              });
              req.on('error', () => resolve(null));
              req.end();
            });
          }

          function aggregateDailyToMonthly(existingAggregated, dailyProduction) {
            // existingAggregated: { "2025-02": { "Tahtali Baraji": 123456, ... }, ... }
            // dailyProduction: { UretimTarihi: "2025-12-28T00:00:00", BarajKuyuUretimleri: [...] }
            const aggregated = existingAggregated ? JSON.parse(JSON.stringify(existingAggregated)) : {};

            if (!dailyProduction || !dailyProduction.UretimTarihi || !dailyProduction.BarajKuyuUretimleri) {
              return aggregated;
            }

            const date = new Date(dailyProduction.UretimTarihi);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            const dayKey = date.toISOString().split('T')[0];

            // Initialize month if not exists
            if (!aggregated[monthKey]) {
              aggregated[monthKey] = { _days: [], _sources: {} };
            }

            // Skip if this day was already aggregated
            if (aggregated[monthKey]._days && aggregated[monthKey]._days.includes(dayKey)) {
              console.log(`Day ${dayKey} already aggregated, skipping`);
              return aggregated;
            }

            // Add each source's production
            for (const item of dailyProduction.BarajKuyuUretimleri) {
              const sourceName = item.BarajKuyuAdi;
              const amount = item.UretimMiktari || 0;

              if (!aggregated[monthKey]._sources[sourceName]) {
                aggregated[monthKey]._sources[sourceName] = 0;
              }
              aggregated[monthKey]._sources[sourceName] += amount;
            }

            // Track which days we've aggregated
            if (!aggregated[monthKey]._days) {
              aggregated[monthKey]._days = [];
            }
            aggregated[monthKey]._days.push(dayKey);

            console.log(`Aggregated ${dayKey}: ${dailyProduction.BarajKuyuUretimleri.length} sources into ${monthKey}`);
            return aggregated;
          }

          function convertAggregatedToDistribution(aggregated) {
            // Convert aggregated data to suuretiminindagilimi format
            // Output: [{ UretimKaynagi: "...", UretimMiktari: N, Yil: YYYY, Ay: M, _days: N }, ...]
            const distribution = [];

            for (const [monthKey, monthData] of Object.entries(aggregated)) {
              const [year, month] = monthKey.split('-').map(Number);
              const sources = monthData._sources || {};
              const daysCount = (monthData._days || []).length;
              const daysInMonth = new Date(year, month, 0).getDate();

              for (const [sourceName, amount] of Object.entries(sources)) {
                distribution.push({
                  UretimKaynagi: sourceName,
                  UretimMiktari: Math.round(amount),
                  Yil: year,
                  Ay: month,
                  _days: daysCount,
                  _daysInMonth: daysInMonth
                });
              }
            }

            return distribution;
          }

          async function updateGist(content) {
            const gistId = process.env.GIST_ID;
            const token = process.env.GIST_TOKEN;

            if (!gistId || !token) {
              console.log('No GIST_ID or GIST_TOKEN - skipping gist update');
              console.log('Data preview:', JSON.stringify(content, null, 2).slice(0, 1000));
              return;
            }

            const payload = JSON.stringify({
              files: {
                'izsu-data.json': {
                  content: JSON.stringify(content, null, 2)
                }
              }
            });

            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'api.github.com',
                path: `/gists/${gistId}`,
                method: 'PATCH',
                headers: {
                  'Authorization': `token ${token}`,
                  'User-Agent': 'IZSU-Fetcher',
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(payload)
                }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    console.log('Gist updated successfully');
                    resolve();
                  } else {
                    console.log(`Gist update failed: ${res.statusCode} - ${data.substring(0, 200)}`);
                    reject(new Error(`Gist update failed: ${res.statusCode}`));
                  }
                });
              });

              req.on('error', reject);
              req.write(payload);
              req.end();
            });
          }

          async function main() {
            const totalStart = Date.now();
            console.log('Starting IZSU data fetch...\n');

            // Fetch existing gist data for aggregation continuity
            console.log('Fetching existing gist data...');
            const existingGist = await fetchGist();
            const existingAggregated = existingGist?.aggregatedMonthly || {};
            console.log(`Existing aggregated months: ${Object.keys(existingAggregated).length}`);

            // Fetch IZSU OpenAPI endpoints sequentially via HTTP/2
            const results = [];
            for (const [name, path] of Object.entries(ENDPOINTS)) {
              const result = await fetchEndpoint(name, path);
              results.push(result);
              await new Promise(r => setTimeout(r, 500));
            }

            // Fetch production distribution for all years (2009-current)
            console.log('\nFetching production distribution by year...');
            const productionData = [];
            for (let year = PRODUCTION_START_YEAR; year <= currentYear; year++) {
              const path = `/api/izsu/suuretiminindagilimi/${year}`;
              const result = await fetchEndpoint(`production_${year}`, path);
              if (!result.error && Array.isArray(result.data)) {
                productionData.push(...result.data);
              }
              await new Promise(r => setTimeout(r, 300));
            }

            // Fetch CKAN endpoints
            console.log('\nFetching CKAN data...');
            for (const [name, url] of Object.entries(CKAN_ENDPOINTS)) {
              const result = await fetchCkanEndpoint(name, url);
              results.push(result);
            }

            // Build data object
            const data = {
              timestamp: new Date().toISOString(),
              endpoints: {},
              ckan: {}
            };

            let successCount = 0;
            let errorCount = 0;

            results.forEach(({ name, data: endpointData, error }) => {
              // Check if it's a CKAN endpoint
              const isCkan = Object.keys(CKAN_ENDPOINTS).includes(name);
              const target = isCkan ? data.ckan : data.endpoints;

              if (error) {
                target[name] = { error };
                errorCount++;
              } else {
                target[name] = endpointData;
                successCount++;
              }
            });

            // Aggregate daily production into monthly totals
            console.log('\nAggregating daily production...');
            const dailyProduction = data.endpoints.gunluksuuretimi;
            const aggregated = aggregateDailyToMonthly(existingAggregated, dailyProduction);
            data.aggregatedMonthly = aggregated;

            // Convert aggregated data to distribution format and merge with official data
            const aggregatedDistribution = convertAggregatedToDistribution(aggregated);
            console.log(`Aggregated distribution: ${aggregatedDistribution.length} records`);

            // Find the latest month in official data
            let latestOfficialYear = 0, latestOfficialMonth = 0;
            for (const item of productionData) {
              if (item.Yil > latestOfficialYear || (item.Yil === latestOfficialYear && item.Ay > latestOfficialMonth)) {
                latestOfficialYear = item.Yil;
                latestOfficialMonth = item.Ay;
              }
            }
            console.log(`Latest official data: ${latestOfficialYear}-${String(latestOfficialMonth).padStart(2, '0')}`);

            // Merge: use official data, then append aggregated data for months after official data
            const mergedProduction = [...productionData];
            for (const item of aggregatedDistribution) {
              const isAfterOfficial = item.Yil > latestOfficialYear ||
                (item.Yil === latestOfficialYear && item.Ay > latestOfficialMonth);
              if (isAfterOfficial) {
                mergedProduction.push(item);
              }
            }

            // Add merged production data
            data.endpoints.suuretiminindagilimi = mergedProduction;
            if (mergedProduction.length > 0) {
              successCount++;
              console.log(`suuretiminindagilimi: ${mergedProduction.length} records (${productionData.length} official + ${mergedProduction.length - productionData.length} aggregated)`);
            }

            console.log(`\nResults: ${successCount} success, ${errorCount} errors`);

            // Update gist
            await updateGist(data);

            const totalElapsed = Date.now() - totalStart;
            console.log(`\nTotal time: ${totalElapsed}ms (${(totalElapsed/1000).toFixed(1)}s)`);

            // Close HTTP/2 client
            if (h2Client) {
              h2Client.close();
            }

            // Exit with error if too many failures
            if (errorCount > successCount) {
              console.log('\nToo many errors, exiting with failure');
              process.exit(1);
            }
          }

          main().catch(err => {
            console.error('Fatal error:', err);
            process.exit(1);
          });
          EOF

  # Fallback job: use self-hosted runner if primary fails
  fetch-fallback:
    runs-on: self-hosted
    needs: fetch-primary
    if: ${{ failure() }}
    timeout-minutes: 5
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch IZSU Data (Fallback)
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
        run: |
          echo "Primary job failed, running on self-hosted runner..."
          node << 'EOF'
          const http2 = require('http2');
          const https = require('https');

          const currentYear = new Date().getFullYear();
          const ENDPOINTS = {
            barajdurum: '/api/izsu/barajdurum',
            barajvekuyular: '/api/izsu/barajvekuyular',
            gunluksuuretimi: '/api/izsu/gunluksuuretimi',
            arizakaynaklisukesintileri: '/api/izsu/arizakaynaklisukesintileri',
            haftaliksuanalizleri: '/api/izsu/haftaliksuanalizleri',
            cevreilcesuanalizleri: '/api/izsu/cevreilcesuanalizleri',
            barajsukaliteraporlari: '/api/izsu/barajsukaliteraporlari'
          };

          const PRODUCTION_START_YEAR = 2009;
          const IZSU_HOST = 'https://openapi.izmir.bel.tr';
          const CKAN_ENDPOINTS = {
            consumption: 'https://acikveri.bizizmir.com/api/3/action/datastore_search?resource_id=7a7485e5-2f04-4daf-9cc0-75ef1c24bc23&limit=0'
          };

          const RETRY_COUNT = 3;
          const TIMEOUT_MS = 30000;
          const BROWSER_HEADERS = {
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'accept-language': 'tr,en-US;q=0.9,en;q=0.8',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/143.0.0.0 Safari/537.36'
          };

          let h2Client = null;
          function getH2Client() {
            if (!h2Client || h2Client.destroyed) {
              h2Client = http2.connect(IZSU_HOST, { rejectUnauthorized: false });
              h2Client.on('error', (err) => console.log('H2 error:', err.message));
            }
            return h2Client;
          }

          function fetchWithHttp2(path, timeoutMs) {
            return new Promise((resolve, reject) => {
              const client = getH2Client();
              const chunks = [];
              let totalSize = 0;
              const req = client.request({ ':path': path, ...BROWSER_HEADERS });
              const timeout = setTimeout(() => { req.close(); reject(new Error('Timeout')); }, timeoutMs);
              req.on('data', chunk => { chunks.push(chunk); totalSize += chunk.length; });
              req.on('end', () => { clearTimeout(timeout); resolve(Buffer.concat(chunks, totalSize).toString('utf8')); });
              req.on('error', (err) => { clearTimeout(timeout); reject(err); });
              req.end();
            });
          }

          async function fetchEndpoint(name, path) {
            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const raw = await fetchWithHttp2(path, TIMEOUT_MS);
                if (!raw || raw.trim() === '') throw new Error('Empty');
                const parsed = JSON.parse(raw);
                if (parsed?.message === 'An unexpected error occurred') throw new Error('API error');
                console.log('OK ' + name + ': ' + Math.round(raw.length/1024) + 'KB');
                return { name, data: parsed, error: null };
              } catch (e) {
                console.log('X ' + name + ' attempt ' + attempt + ': ' + e.message);
                if (attempt < RETRY_COUNT) await new Promise(r => setTimeout(r, 1000 * attempt));
              }
            }
            return { name, data: null, error: 'Failed' };
          }

          async function fetchCkanEndpoint(name, url) {
            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const raw = await new Promise((resolve, reject) => {
                  const chunks = [];
                  https.get(url, { headers: BROWSER_HEADERS }, (res) => {
                    res.on('data', c => chunks.push(c));
                    res.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
                    res.on('error', reject);
                  }).on('error', reject);
                });
                const parsed = JSON.parse(raw);
                if (parsed?.success && parsed?.result) {
                  console.log('[CKAN] ' + name + ': total=' + parsed.result.total);
                  return { name, data: { total: parsed.result.total }, error: null };
                }
                throw new Error('CKAN failed');
              } catch (e) {
                if (attempt < RETRY_COUNT) await new Promise(r => setTimeout(r, 1000 * attempt));
              }
            }
            return { name, data: null, error: 'Failed' };
          }

          async function fetchGist() {
            const gistId = process.env.GIST_ID, token = process.env.GIST_TOKEN;
            if (!gistId || !token) return null;
            return new Promise((resolve) => {
              const req = https.request({
                hostname: 'api.github.com', path: '/gists/' + gistId, method: 'GET',
                headers: { 'Authorization': 'token ' + token, 'User-Agent': 'IZSU', 'Accept': 'application/vnd.github.v3+json' }
              }, (res) => {
                let d = ''; res.on('data', c => d += c);
                res.on('end', () => {
                  try { const g = JSON.parse(d); resolve(g.files['izsu-data.json']?.content ? JSON.parse(g.files['izsu-data.json'].content) : null); }
                  catch { resolve(null); }
                });
              });
              req.on('error', () => resolve(null)); req.end();
            });
          }

          function aggregateDailyToMonthly(existing, daily) {
            const agg = existing ? JSON.parse(JSON.stringify(existing)) : {};
            if (!daily?.UretimTarihi || !daily?.BarajKuyuUretimleri) return agg;
            const date = new Date(daily.UretimTarihi);
            const monthKey = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0');
            const dayKey = date.toISOString().split('T')[0];
            if (!agg[monthKey]) agg[monthKey] = { _days: [], _sources: {} };
            if (agg[monthKey]._days?.includes(dayKey)) return agg;
            for (const item of daily.BarajKuyuUretimleri) {
              const src = item.BarajKuyuAdi;
              agg[monthKey]._sources[src] = (agg[monthKey]._sources[src] || 0) + (item.UretimMiktari || 0);
            }
            agg[monthKey]._days.push(dayKey);
            console.log('Aggregated ' + dayKey + ' into ' + monthKey);
            return agg;
          }

          function convertAggregatedToDistribution(agg) {
            const dist = [];
            for (const [mk, md] of Object.entries(agg)) {
              const [y, m] = mk.split('-').map(Number);
              const daysCount = (md._days || []).length;
              const daysInMonth = new Date(y, m, 0).getDate();
              for (const [src, amt] of Object.entries(md._sources || {})) {
                dist.push({ UretimKaynagi: src, UretimMiktari: Math.round(amt), Yil: y, Ay: m, _days: daysCount, _daysInMonth: daysInMonth });
              }
            }
            return dist;
          }

          async function updateGist(content) {
            const gistId = process.env.GIST_ID, token = process.env.GIST_TOKEN;
            if (!gistId || !token) { console.log('No gist credentials'); return; }
            const payload = JSON.stringify({ files: { 'izsu-data.json': { content: JSON.stringify(content, null, 2) } } });
            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'api.github.com', path: '/gists/' + gistId, method: 'PATCH',
                headers: { 'Authorization': 'token ' + token, 'User-Agent': 'IZSU', 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(payload) }
              }, (res) => {
                let d = ''; res.on('data', c => d += c);
                res.on('end', () => { res.statusCode === 200 ? (console.log('Gist updated'), resolve()) : reject(new Error('Gist ' + res.statusCode)); });
              });
              req.on('error', reject); req.write(payload); req.end();
            });
          }

          async function main() {
            console.log('Starting fallback fetch...');
            const existingGist = await fetchGist();
            const existingAgg = existingGist?.aggregatedMonthly || {};

            const results = [];
            for (const [name, path] of Object.entries(ENDPOINTS)) {
              results.push(await fetchEndpoint(name, path));
              await new Promise(r => setTimeout(r, 500));
            }
            console.log('Fetching production data...');
            const productionData = [];
            for (let year = PRODUCTION_START_YEAR; year <= currentYear; year++) {
              const result = await fetchEndpoint('prod_' + year, '/api/izsu/suuretiminindagilimi/' + year);
              if (!result.error && Array.isArray(result.data)) productionData.push(...result.data);
              await new Promise(r => setTimeout(r, 300));
            }
            console.log('Fetching CKAN...');
            for (const [name, url] of Object.entries(CKAN_ENDPOINTS)) results.push(await fetchCkanEndpoint(name, url));

            const data = { timestamp: new Date().toISOString(), endpoints: {}, ckan: {} };
            let ok = 0, err = 0;
            results.forEach(({ name, data: d, error }) => {
              const t = Object.keys(CKAN_ENDPOINTS).includes(name) ? data.ckan : data.endpoints;
              if (error) { t[name] = { error }; err++; } else { t[name] = d; ok++; }
            });

            // Aggregate daily to monthly
            const agg = aggregateDailyToMonthly(existingAgg, data.endpoints.gunluksuuretimi);
            data.aggregatedMonthly = agg;
            const aggDist = convertAggregatedToDistribution(agg);

            // Find latest official month
            let latestY = 0, latestM = 0;
            for (const i of productionData) {
              if (i.Yil > latestY || (i.Yil === latestY && i.Ay > latestM)) { latestY = i.Yil; latestM = i.Ay; }
            }

            // Merge official + aggregated
            const merged = [...productionData];
            for (const i of aggDist) {
              if (i.Yil > latestY || (i.Yil === latestY && i.Ay > latestM)) merged.push(i);
            }
            data.endpoints.suuretiminindagilimi = merged;
            if (merged.length > 0) ok++;
            console.log('Production: ' + productionData.length + ' official + ' + (merged.length - productionData.length) + ' aggregated');
            console.log('Results: ' + ok + ' ok, ' + err + ' errors');
            await updateGist(data);
            if (h2Client) h2Client.close();
            if (err > ok) process.exit(1);
          }
          main().catch(e => { console.error('Fatal:', e); process.exit(1); });
          EOF

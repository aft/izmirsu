name: Fetch IZSU Data

on:
  # Manual trigger for testing
  workflow_dispatch:
  # Hourly schedule
  schedule:
    - cron: '0 * * * *'

jobs:
  fetch:
    runs-on: self-hosted
    timeout-minutes: 5
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch IZSU Data
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
        run: |
          node << 'EOF'
          const https = require('https');

          // Skip SSL verification
          const agent = new https.Agent({ rejectUnauthorized: false });

          // IZSU OpenAPI endpoints (expired SSL - need rejectUnauthorized: false)
          const currentYear = new Date().getFullYear();
          const ENDPOINTS = {
            barajdurum: 'https://openapi.izmir.bel.tr/api/izsu/barajdurum',
            barajvekuyular: 'https://openapi.izmir.bel.tr/api/izsu/barajvekuyular',
            gunluksuuretimi: 'https://openapi.izmir.bel.tr/api/izsu/gunluksuuretimi',
            arizakaynaklisukesintileri: 'https://openapi.izmir.bel.tr/api/izsu/arizakaynaklisukesintileri',
            haftaliksuanalizleri: 'https://openapi.izmir.bel.tr/api/izsu/haftaliksuanalizleri',
            cevreilcesuanalizleri: 'https://openapi.izmir.bel.tr/api/izsu/cevreilcesuanalizleri',
            barajsukaliteraporlari: 'https://openapi.izmir.bel.tr/api/izsu/barajsukaliteraporlari'
          };

          // Production distribution needs year parameter (2009-current)
          const PRODUCTION_START_YEAR = 2009;

          // CKAN endpoints (valid SSL)
          const CKAN_ENDPOINTS = {
            consumption: 'https://acikveri.bizizmir.com/api/3/action/datastore_search?resource_id=7a7485e5-2f04-4daf-9cc0-75ef1c24bc23&limit=0'
          };

          const RETRY_COUNT = 3;
          const TIMEOUT_MS = 30000;

          // Browser-like headers (required by some endpoints)
          const BROWSER_HEADERS = {
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
            'accept-language': 'tr,en-US;q=0.9,en;q=0.8',
            'cache-control': 'no-cache',
            'dnt': '1',
            'pragma': 'no-cache',
            'priority': 'u=0, i',
            'sec-ch-ua': '"Google Chrome";v="143", "Chromium";v="143", "Not A(Brand";v="24"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"Windows"',
            'sec-fetch-dest': 'document',
            'sec-fetch-mode': 'navigate',
            'sec-fetch-site': 'none',
            'sec-fetch-user': '?1',
            'upgrade-insecure-requests': '1',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36'
          };

          function fetchWithTimeout(url, timeoutMs) {
            return new Promise((resolve, reject) => {
              const chunks = [];
              let totalSize = 0;

              const req = https.get(url, { agent, headers: BROWSER_HEADERS }, (res) => {
                res.on('data', chunk => {
                  chunks.push(chunk);
                  totalSize += chunk.length;
                });
                res.on('end', () => {
                  const buffer = Buffer.concat(chunks, totalSize);
                  resolve(buffer.toString('utf8'));
                });
                res.on('error', reject);
              });

              req.on('error', reject);
              req.setTimeout(timeoutMs, () => {
                req.destroy();
                reject(new Error('Request timeout'));
              });
            });
          }

          async function fetchEndpoint(name, url) {
            const startTime = Date.now();

            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const rawData = await fetchWithTimeout(url, TIMEOUT_MS);
                const elapsed = Date.now() - startTime;

                // Check if response is valid
                if (!rawData || rawData.trim() === '') {
                  throw new Error('Empty response');
                }

                // Try to parse JSON
                let parsed;
                try {
                  parsed = JSON.parse(rawData);
                } catch (parseErr) {
                  // Log first 200 chars for debugging
                  console.log(`  Parse error preview: ${rawData.substring(0, 200)}`);
                  throw new Error(`JSON parse error: ${parseErr.message}`);
                }

                // Check for API error in response
                if (parsed && parsed.message === 'An unexpected error occurred') {
                  throw new Error('API returned error message');
                }

                console.log(`✓ ${name}: ${elapsed}ms (${Math.round(rawData.length/1024)}KB)`);
                return { name, data: parsed, error: null };

              } catch (error) {
                const elapsed = Date.now() - startTime;
                console.log(`✗ ${name} attempt ${attempt}/${RETRY_COUNT}: ${error.message} (${elapsed}ms)`);

                if (attempt < RETRY_COUNT) {
                  // Wait before retry with exponential backoff
                  await new Promise(r => setTimeout(r, 1000 * attempt));
                }
              }
            }

            return { name, data: null, error: `Failed after ${RETRY_COUNT} attempts` };
          }

          // Fetch CKAN endpoint (valid SSL - no agent needed)
          async function fetchCkanEndpoint(name, url) {
            const startTime = Date.now();

            for (let attempt = 1; attempt <= RETRY_COUNT; attempt++) {
              try {
                const rawData = await new Promise((resolve, reject) => {
                  const chunks = [];
                  let totalSize = 0;

                  const req = https.get(url, { headers: BROWSER_HEADERS }, (res) => {
                    res.on('data', chunk => {
                      chunks.push(chunk);
                      totalSize += chunk.length;
                    });
                    res.on('end', () => {
                      const buffer = Buffer.concat(chunks, totalSize);
                      resolve(buffer.toString('utf8'));
                    });
                    res.on('error', reject);
                  });

                  req.on('error', reject);
                  req.setTimeout(TIMEOUT_MS, () => {
                    req.destroy();
                    reject(new Error('Request timeout'));
                  });
                });

                const elapsed = Date.now() - startTime;

                if (!rawData || rawData.trim() === '') {
                  throw new Error('Empty response');
                }

                let parsed;
                try {
                  parsed = JSON.parse(rawData);
                } catch (parseErr) {
                  console.log(`  Parse error preview: ${rawData.substring(0, 200)}`);
                  throw new Error(`JSON parse error: ${parseErr.message}`);
                }

                // CKAN returns { success: true, result: { total: N, ... } }
                if (parsed && parsed.success && parsed.result) {
                  console.log(`[CKAN] ${name}: ${elapsed}ms (total: ${parsed.result.total})`);
                  return { name, data: { total: parsed.result.total }, error: null };
                } else {
                  throw new Error('CKAN API returned unsuccessful response');
                }

              } catch (error) {
                const elapsed = Date.now() - startTime;
                console.log(`[CKAN] ${name} attempt ${attempt}/${RETRY_COUNT}: ${error.message} (${elapsed}ms)`);

                if (attempt < RETRY_COUNT) {
                  await new Promise(r => setTimeout(r, 1000 * attempt));
                }
              }
            }

            return { name, data: null, error: `Failed after ${RETRY_COUNT} attempts` };
          }

          async function updateGist(content) {
            const gistId = process.env.GIST_ID;
            const token = process.env.GIST_TOKEN;

            if (!gistId || !token) {
              console.log('No GIST_ID or GIST_TOKEN - skipping gist update');
              console.log('Data preview:', JSON.stringify(content, null, 2).slice(0, 1000));
              return;
            }

            const payload = JSON.stringify({
              files: {
                'izsu-data.json': {
                  content: JSON.stringify(content, null, 2)
                }
              }
            });

            return new Promise((resolve, reject) => {
              const req = https.request({
                hostname: 'api.github.com',
                path: `/gists/${gistId}`,
                method: 'PATCH',
                headers: {
                  'Authorization': `token ${token}`,
                  'User-Agent': 'IZSU-Fetcher',
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(payload)
                }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    console.log('✓ Gist updated successfully');
                    resolve();
                  } else {
                    console.log(`✗ Gist update failed: ${res.statusCode} - ${data.substring(0, 200)}`);
                    reject(new Error(`Gist update failed: ${res.statusCode}`));
                  }
                });
              });

              req.on('error', reject);
              req.write(payload);
              req.end();
            });
          }

          async function main() {
            const totalStart = Date.now();
            console.log('Starting IZSU data fetch...\n');

            // Fetch IZSU OpenAPI endpoints sequentially
            const results = [];
            for (const [name, url] of Object.entries(ENDPOINTS)) {
              const result = await fetchEndpoint(name, url);
              results.push(result);
              await new Promise(r => setTimeout(r, 500));
            }

            // Fetch production distribution for all years (2010-current)
            console.log('\nFetching production distribution by year...');
            const productionData = [];
            for (let year = PRODUCTION_START_YEAR; year <= currentYear; year++) {
              const url = `https://openapi.izmir.bel.tr/api/izsu/suuretiminindagilimi/${year}`;
              const result = await fetchEndpoint(`production_${year}`, url);
              if (!result.error && Array.isArray(result.data)) {
                productionData.push(...result.data);
              }
              await new Promise(r => setTimeout(r, 300));
            }

            // Fetch CKAN endpoints
            console.log('\nFetching CKAN data...');
            for (const [name, url] of Object.entries(CKAN_ENDPOINTS)) {
              const result = await fetchCkanEndpoint(name, url);
              results.push(result);
            }

            // Build data object
            const data = {
              timestamp: new Date().toISOString(),
              endpoints: {},
              ckan: {}
            };

            let successCount = 0;
            let errorCount = 0;

            results.forEach(({ name, data: endpointData, error }) => {
              // Check if it's a CKAN endpoint
              const isCkan = Object.keys(CKAN_ENDPOINTS).includes(name);
              const target = isCkan ? data.ckan : data.endpoints;

              if (error) {
                target[name] = { error };
                errorCount++;
              } else {
                target[name] = endpointData;
                successCount++;
              }
            });

            // Add merged production data
            data.endpoints.suuretiminindagilimi = productionData;
            if (productionData.length > 0) {
              successCount++;
              console.log(`suuretiminindagilimi: ${productionData.length} records (${PRODUCTION_START_YEAR}-${currentYear})`);
            }

            console.log(`\nResults: ${successCount} success, ${errorCount} errors`);

            // Update gist
            await updateGist(data);

            const totalElapsed = Date.now() - totalStart;
            console.log(`\nTotal time: ${totalElapsed}ms (${(totalElapsed/1000).toFixed(1)}s)`);

            // Exit with error if too many failures
            if (errorCount > successCount) {
              console.log('\nToo many errors, exiting with failure');
              process.exit(1);
            }
          }

          main().catch(err => {
            console.error('Fatal error:', err);
            process.exit(1);
          });
          EOF
